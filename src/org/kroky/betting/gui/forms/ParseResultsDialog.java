/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.kroky.betting.gui.forms;

import foxtrot.AsyncTask;
import foxtrot.AsyncWorker;
import java.sql.Timestamp;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.swing.Icon;
import javax.swing.JOptionPane;
import javax.swing.SortOrder;
import org.apache.log4j.Logger;
import static org.kroky.betting.common.enums.BetStatus.CANCELED;
import static org.kroky.betting.common.enums.BetStatus.LOST;
import static org.kroky.betting.common.enums.BetStatus.WON;
import org.kroky.betting.common.enums.MatchResult;
import org.kroky.betting.common.exceptions.BettingRuntimeException;
import org.kroky.betting.common.util.Resources;
import org.kroky.betting.common.util.TeamNameMapper;
import org.kroky.betting.common.util.Utils;
import org.kroky.betting.db.DAO;
import static org.kroky.betting.db.DBState.isAdded;
import static org.kroky.betting.db.DBState.setAdded;
import org.kroky.betting.db.objects.Bet;
import org.kroky.betting.db.objects.Match;
import org.kroky.betting.db.objects.Team;
import org.kroky.betting.db.objects.TeamMapping;
import org.kroky.betting.gui.custom.EscapableDialog;
import org.kroky.betting.gui.custom.tables.EditableTable;
import org.kroky.betting.gui.custom.tables.ParseMatchesTableModel;
import org.kroky.betting.parsers.ParseResult;

/**
 *
 * @author Kroky
 */
public class ParseResultsDialog extends EscapableDialog {

    private static final Logger LOG = Logger.getLogger(ParseResultsDialog.class);

    public ParseResultsDialog(MainFrame parent, boolean modal, Set<ParseResult> results) {
        super(parent, modal);
        this.results = results;
        this.parent = parent;
        initComponents();
        additionalInit();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonCancel = new javax.swing.JButton();
        buttonUpdate = new javax.swing.JButton();
        progressBarUpdate = new javax.swing.JProgressBar(0, results.size());
        jLabel1 = new javax.swing.JLabel();
        labelMatches = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        labelTeams = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        labelDraws = new javax.swing.JLabel();
        scrollPaneMatchesTable = new javax.swing.JScrollPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Preview Results");

        buttonCancel.setText("Cancel");
        buttonCancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonCancelActionPerformed(evt);
            }
        });

        buttonUpdate.setText("Update DB");
        buttonUpdate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonUpdateActionPerformed(evt);
            }
        });

        jLabel1.setText("Matches:");

        labelMatches.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        labelMatches.setText("0");

        jLabel2.setText("Teams:");

        labelTeams.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        labelTeams.setText("0");

        jLabel4.setText("Draws:");

        labelDraws.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        labelDraws.setText("0");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(progressBarUpdate, javax.swing.GroupLayout.DEFAULT_SIZE, 552, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(buttonUpdate, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(buttonCancel, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelMatches)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelTeams)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelDraws))
                    .addComponent(scrollPaneMatchesTable))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {buttonCancel, buttonUpdate});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(labelMatches)
                    .addComponent(jLabel2)
                    .addComponent(labelTeams)
                    .addComponent(jLabel4)
                    .addComponent(labelDraws))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scrollPaneMatchesTable, javax.swing.GroupLayout.DEFAULT_SIZE, 356, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(progressBarUpdate, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonUpdate)
                    .addComponent(buttonCancel))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void buttonCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonCancelActionPerformed
        dispose();
    }//GEN-LAST:event_buttonCancelActionPerformed

    private void buttonUpdateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonUpdateActionPerformed
        //<editor-fold defaultstate="collapsed" desc="...">
        TeamNameMapper mapper = TeamNameMapper.getInstance();
        Set<TeamMapping> mappings = new HashSet<TeamMapping>();
        for (TeamMapping mapping : allMappings) {
            if (!mapper.containsMapping(mapping.getId())) {
                mappings.add(mapping);
            }
        }
        boolean accepted = false;
        if (!mappings.isEmpty()) {
            TeamMappingDialog mappingDialog = new TeamMappingDialog(this, true, mappings);
            mappingDialog.setVisible(true);
            newMappings = mappingDialog.getNewMappings();
            accepted = mappingDialog.wasAccepted();
        }
        if (accepted || mappings.isEmpty()) {
            AsyncWorker.post(new UpdateDbTask());
        }
        //</editor-fold>
    }//GEN-LAST:event_buttonUpdateActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buttonCancel;
    private javax.swing.JButton buttonUpdate;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel labelDraws;
    private javax.swing.JLabel labelMatches;
    private javax.swing.JLabel labelTeams;
    private javax.swing.JProgressBar progressBarUpdate;
    private javax.swing.JScrollPane scrollPaneMatchesTable;
    // End of variables declaration//GEN-END:variables

    private Set<ParseResult> results;
    private MainFrame parent;
    private EditableTable matchesTable = new EditableTable(new ParseMatchesTableModel(), 0, SortOrder.DESCENDING);
    private Set<TeamMapping> allMappings = new HashSet<TeamMapping>();
    private Set<TeamMapping> newMappings = new HashSet<TeamMapping>();

    private void additionalInit() {
        //<editor-fold defaultstate="collapsed" desc="...">
        progressBarUpdate.setVisible(false);
        int drawCounter = 0;
        Set<String> teams = new HashSet<String>();
        ParseMatchesTableModel model = (ParseMatchesTableModel) matchesTable.getModel();
        for (ParseResult r : results) {
            Timestamp date = r.getDate();
            String homeTeamName = r.getHomeTeamName();
            String awayTeamName = r.getAwayTeamName();
            String sport = r.getSport();
            String country = r.getCountry();
            String league = r.getLeague();
            String season = r.getSeason();
            Icon icon = null;
            if (r.getResult().equals(MatchResult.DRAW)) {
                icon = Resources.getCheckIcon(16, 16);
                drawCounter++;
            } else if (r.getResult().equals(MatchResult.CANCELED)) {
                icon = Resources.getCanceledIcon(16, 16);
            }
            Object[] rowData = new Object[]{Utils.formatDateTime(date), homeTeamName, awayTeamName, icon, country, sport, league, season};
            model.addRow(rowData);
            allMappings.add(new TeamMapping(homeTeamName, country, sport, league, null));
            allMappings.add(new TeamMapping(awayTeamName, country, sport, league, null));
            teams.add(homeTeamName);
            teams.add(awayTeamName);
        }
        scrollPaneMatchesTable.setViewportView(matchesTable);
        matchesTable.packAll();
        labelMatches.setText(String.valueOf(results.size()));
        labelTeams.setText(String.valueOf(teams.size()));
        String percent = Utils.formatTwoDecimal(((double) drawCounter / (double) results.size()) * 100.0);
        labelDraws.setText(drawCounter + " (" + percent + "%)");

        Utils.centerOnParent(parent, this);
        //</editor-fold>
    }

    //<editor-fold defaultstate="collapsed" desc="UpdateDbTask">
    private class UpdateDbTask extends AsyncTask {

        private final Logger LOG = Logger.getLogger(UpdateDbTask.class);

        int defaultCloseOperation = ParseResultsDialog.this.getDefaultCloseOperation();

        @Override
        public Object run() {
            progressBarUpdate.setStringPainted(true);
            progressBarUpdate.setValue(0);
            ParseResultsDialog.this.setDefaultCloseOperation(ParseResultsDialog.DO_NOTHING_ON_CLOSE);
//            DAO.begin();
            List<Bet> bets = DAO.getActiveBets();
            progressBarUpdate.setMaximum(newMappings.size() + results.size() + bets.size());
            progressBarUpdate.setVisible(true);
            buttonUpdate.setEnabled(false);
            buttonCancel.setEnabled(false);
            int i = 0;
            //update teams and mappings
            String message = "Updating teams and mappings...";
            LOG.debug(message);
            int teamCount = 0;
            for (TeamMapping mapping : newMappings) {
                i++;
                progressBarUpdate.setValue(i);
                progressBarUpdate.setString(message);
                //first we save team
                Team team = mapping.getTeam();
                team = DAO.insertTeam(team);
                if (isAdded(Team.class)) {
                    teamCount++;
                    setAdded(Team.class, false);
                }
                //then mapping
                mapping.setTeam(team);
                DAO.insertTeamMapping(mapping);
            }

            if (!newMappings.isEmpty()) {
                setAdded(TeamMapping.class, true);
            }

            TeamNameMapper mapper = TeamNameMapper.getInstance();
            //Do I replace the leagues/countries/sports with the string from provider?
//            for (TeamMapping mapping : allMappings) {
//
//            }
            //update matches
            List<Match> matches = new ArrayList<Match>();
            int matchCount = 0;
            message = "Updating matches...";
            LOG.debug(message);
            for (ParseResult r : results) {
                i++;
                progressBarUpdate.setValue(i);
                progressBarUpdate.setString(message);
                Team homeTeam = mapper.getTeam(r.getHomeTeamName(), r.getSport(), r.getCountry());
                Team awayTeam = mapper.getTeam(r.getAwayTeamName(), r.getSport(), r.getCountry());
                Match match = DAO.addMatchToTeam(r.getDate(), homeTeam, awayTeam, r.getHomeGoals(), r.getAwayGoals(), r.getSeason(), r.getLeague(), r.getResult());
                matches.add(match);
                if (isAdded(Match.class)) {
                    matchCount++;
                    setAdded(Match.class, false);
                }
            }
            message = "Updating bets with latest results...";
            LOG.debug(message);
            progressBarUpdate.setString(message);
            int betCount = 0;
            int won = 0;
            int lost = 0;
            for (Bet bet : bets) {
                i++;
                progressBarUpdate.setValue(i);
                if (updateBet(bet, matches)) {
                    betCount++;
                    if (WON.equals(bet.getStatus())) {
                        won++;
                    } else if (LOST.equals(bet.getStatus())) {
                        lost++;
                    }
                    final Team activeTeam = bet.getActiveTeam();
                    activeTeam.setResultUpdated(Utils.now());
                    DAO.saveOrUpdateTeam(activeTeam);
                }
            }
//            DAO.commit();
            progressBarUpdate.setValue(i);
            message = MessageFormat.format("Team additions: {0}\nResults additions: {1}\nNew team mappings: {2}\nBets updated: {3}\nWon: {4}\nLost: {5}\nCanceled: {6}",
                    teamCount, matchCount, newMappings.size(), betCount, won, lost, canceledBetCount);
            LOG.debug(message);
            JOptionPane.showMessageDialog(ParseResultsDialog.this, message, "DB Update Report", JOptionPane.INFORMATION_MESSAGE);
            ParseResultsDialog.this.dispose();
            return null;
        }

        @Override
        public void success(Object result) {
//            DAO.closeSession();
            progressBarUpdate.setVisible(false);
            buttonUpdate.setEnabled(true);
            buttonCancel.setEnabled(true);
            ParseResultsDialog.this.setDefaultCloseOperation(defaultCloseOperation);
        }

        @Override
        public void failure(Throwable ex) {
//            DAO.rollback();
//            DAO.closeSession();
            progressBarUpdate.setVisible(false);
            buttonUpdate.setEnabled(true);
            buttonCancel.setEnabled(true);
            ParseResultsDialog.this.setDefaultCloseOperation(defaultCloseOperation);
            if (ex instanceof BettingRuntimeException) {
                throw (BettingRuntimeException) ex;
            }
            throw new BettingRuntimeException("Unknown error", "Unknown error", ex);
        }

        private int canceledBetCount = 0;

        private boolean updateBet(Bet bet, List<Match> matches) {
            for (Match m : matches) {
                Timestamp dayPrecisionDate = Utils.getTimestampAtDayPrecision(bet.getMatchDate());
                if (dayPrecisionDate.equals(m.getDate())
                        && bet.getHomeTeam().equals(m.getHomeTeam())
                        && bet.getAwayTeam().equals(m.getAwayTeam())) {
                    bet.setHomeTeamGoals(m.getHomeGoals());
                    bet.setAwayTeamGoals(m.getAwayGoals());
                    if (MatchResult.CANCELED.equals(m.getResult())) {
                        bet.setStatus(CANCELED);
                        canceledBetCount++;
                    } else {
                        if (MatchResult.DRAW.equals(m.getResult())) {
                            bet.setStatus(WON);
                            if (bet.getHomeTeamGoals() != null) {
                                bet.setStatus(m.getHomeGoals().intValue() == bet.getHomeTeamGoals().intValue() ? WON : LOST);
                            }
                        } else {
                            bet.setStatus(LOST);
                        }
                    }
                    bet.getActiveTeam().setNextMatchDate(null);
                    bet.setUpdated(Utils.now());
                    DAO.saveOrUpdateBet(bet);
                    return true;
                }
            }
            return false;
        }
    }
    //</editor-fold>
}
